import pg8000.native
try:
    from src.config import DB_URI
except ImportError:
    from config import DB_URI
import urllib.parse

DB_PATH = None

class PostgresCursor:
    """Wrapper for pg8000 connection to emulate sqlite3 cursor behavior."""
    def __init__(self, conn):
        self.conn = conn
        self.last_result = None
        self.rowcount = -1

    def execute(self, query, params=None):
        # Translate SQLite '?' placeholders to Postgres '%s'
        # pg8000 uses :param style or literal replacement, but native interface is simpler
        # actually pg8000.native uses literal SQL or prepared statements.
        
        # Let's use the DBAPI interface of pg8000 (pg8000.dbapi) for better compatibility
        # But wait, I imported native. Let's switch to dbapi.
        pass

# Re-implementing using pg8000.dbapi for easier transition
import pg8000.dbapi

class PostgresCursorWrapper:
    def __init__(self, cursor):
        self.cursor = cursor
        self.row_factory = None  # Add row_factory support

    def execute(self, query, params=None):
        # Translate SQLite '?' to Postgres '%s'
        query = query.replace('?', '%s')
        query = query.replace('AUTOINCREMENT', 'GENERATED BY DEFAULT AS IDENTITY')
        query = query.replace('DATETIME', 'TIMESTAMP')
        
        try:
            if params:
                self.cursor.execute(query, params)
            else:
                self.cursor.execute(query)
        except Exception as e:
            print(f"SQL Error: {e} \nQuery: {query}")
            raise e

    def _make_dict_row(self, row):
        """Convert a row tuple to a dictionary-like object if row_factory is set."""
        if self.row_factory and row:
            # Create a dict mapping column names to values
            col_names = [d[0] for d in self.cursor.description]
            return dict(zip(col_names, row))
        return row

    def fetchone(self):
        row = self.cursor.fetchone()
        return self._make_dict_row(row)

    def fetchall(self):
        rows = self.cursor.fetchall()
        if self.row_factory:
            col_names = [d[0] for d in self.cursor.description]
            return [dict(zip(col_names, row)) for row in rows]
        return rows

    def close(self):
        self.cursor.close()
    
    @property
    def rowcount(self):
        return self.cursor.rowcount
    
    @property
    def description(self):
        return self.cursor.description
    
    @property
    def lastrowid(self):
        # Postgres doesn't support lastrowid directly in the same way.
        # For now return None or implement RETURNING clause logic if needed.
        return None

import ssl

class PostgresConnection:
    def __init__(self):
        # Parse DB_URI
        # postgresql://user:password@host:port/database
        result = urllib.parse.urlparse(DB_URI)
        username = result.username
        password = result.password
        database = result.path[1:]
        hostname = result.hostname
        port = result.port
        
        ssl_context = ssl.create_default_context()
        ssl_context.check_hostname = False
        ssl_context.verify_mode = ssl.CERT_NONE
        
        self.conn = pg8000.dbapi.connect(
            user=username,
            password=password,
            host=hostname,
            port=port,
            database=database,
            ssl_context=ssl_context
        )
        
        # pg8000 is autocommit=False by default in DBAPI
        self.row_factory = True

    def cursor(self):
        cursor = PostgresCursorWrapper(self.conn.cursor())
        cursor.row_factory = self.row_factory
        return cursor

    def commit(self):
        self.conn.commit()

    def rollback(self):
        self.conn.rollback()

    def close(self):
        self.conn.close()
    
    def execute(self, query, params=None):
        cursor = self.cursor()
        cursor.execute(query, params)
        return cursor

def get_db_connection():
    return PostgresConnection()

def log_action(user_id, action, details):
    """Logs a user action to the audit_logs table."""
    conn = get_db_connection()
    try:
        conn.execute("INSERT INTO audit_logs (user_id, action, details) VALUES (%s, %s, %s)", (user_id, action, details))
        conn.commit()
    except Exception as e:
        print(f"Error logging action: {e}")
    finally:
        conn.close()

def init_db():
    """Initializes the database schema in Postgres."""
    conn = get_db_connection()
    cursor = conn.cursor()
    
    # Users table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS users (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            username TEXT UNIQUE NOT NULL,
            password TEXT NOT NULL,
            role TEXT NOT NULL,
            full_name TEXT,
            analyst_name TEXT,
            analyst_phone TEXT,
            permissions TEXT
        )
    ''')
    
    # Clients table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS clients (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            dni TEXT UNIQUE NOT NULL,
            first_name TEXT NOT NULL,
            last_name TEXT NOT NULL,
            phone TEXT,
            address TEXT,
            email TEXT,
            work_address TEXT,
            occupation TEXT,
            photo_path TEXT,
            analyst_id INTEGER,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
        )
    ''')
    
    # Loans table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS loans (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            client_id INTEGER,
            loan_type TEXT NOT NULL,
            amount REAL NOT NULL,
            interest_rate REAL,
            start_date DATE,
            due_date DATE,
            end_date DATE, -- Added for compatibility
            original_amount REAL, -- Added for compatibility
            collateral TEXT, -- Added for compatibility
            collateral_sale_price REAL, -- Added for compatibility
            status TEXT DEFAULT 'active',
            refinance_count INTEGER DEFAULT 0,
            parent_loan_id INTEGER,
            frozen_amount REAL DEFAULT 0,
            admin_fee REAL DEFAULT 0,
            sales_expense REAL DEFAULT 0,
            sale_price REAL DEFAULT 0,
            frozen_date DATE,
            analyst_id INTEGER,
            FOREIGN KEY (client_id) REFERENCES clients (id)
        )
    ''')
    
    # Pawn Details table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS pawn_details (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            loan_id INTEGER,
            item_type TEXT,
            brand TEXT,
            characteristics TEXT,
            condition TEXT,
            market_value REAL,
            description TEXT, -- Added for compatibility
            material TEXT, -- Added for compatibility
            weight REAL, -- Added for compatibility
            karat TEXT, -- Added for compatibility
            FOREIGN KEY (loan_id) REFERENCES loans (id) ON DELETE CASCADE
        )
    ''')
    
    # Transactions table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS transactions (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            type TEXT NOT NULL,
            category TEXT,
            amount REAL NOT NULL,
            description TEXT,
            date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            user_id INTEGER,
            loan_id INTEGER,
            payment_method TEXT DEFAULT 'efectivo',
            cash_session_id INTEGER,
            FOREIGN KEY (user_id) REFERENCES users (id),
            FOREIGN KEY (loan_id) REFERENCES loans (id)
        )
    ''')
    
    # Cash Sessions table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS cash_sessions (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            user_id INTEGER NOT NULL,
            opening_balance REAL NOT NULL,
            opening_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            closing_balance REAL,
            closing_date TIMESTAMP,
            status TEXT DEFAULT 'open',
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    ''')
    
    # Installments table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS installments (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            loan_id INTEGER,
            number INTEGER,
            due_date DATE,
            amount REAL,
            status TEXT DEFAULT 'pending',
            paid_amount REAL DEFAULT 0,
            payment_date DATE,
            payment_method TEXT DEFAULT 'efectivo',
            FOREIGN KEY (loan_id) REFERENCES loans (id) ON DELETE CASCADE
        )
    ''')
    
    # Settings table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS settings (
            key TEXT PRIMARY KEY,
            value TEXT,
            description TEXT
        )
    ''')
    
    # Notifications table
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS notifications (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            description TEXT NOT NULL,
            notify_date TIMESTAMP NOT NULL,
            created_by INTEGER,
            is_done BOOLEAN DEFAULT FALSE,
            created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (created_by) REFERENCES users (id)
        )
    ''')

    # Audit Logs
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS audit_logs (
            id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
            user_id INTEGER,
            action TEXT,
            details TEXT,
            timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            FOREIGN KEY (user_id) REFERENCES users (id)
        )
    ''')
    
    # Default Settings (Insert if not exists)
    default_settings = [
        ('company_name', 'Mi Empresa S.A.C.', 'Nombre de la Empresa'),
        ('company_registry', '', 'Partida Registral'),
        ('company_ruc', '20123456789', 'RUC'),
        ('company_manager', '', 'Gerente General'),
        ('manager_dni', '', 'DNI del Gerente'),
        ('company_address', 'Av. Principal 123', 'Dirección de la Empresa'),
        ('company_phone', '999 999 999', 'Teléfono de la Empresa'),
        ('company_phone2', '', 'Teléfono de la Empresa 2'),
        ('manager_phone', '', 'Teléfono del Gerente'),
        ('manager_address', '', 'Dirección del Gerente'),
        ('analyst_name', 'Analista', 'Nombre del Analista'),
        ('analyst_phone', '999 999 999', 'Teléfono del Analista'),
        ('interest_pawn', '5.0', 'Tasa de Interés - Empeño (%)'),
        ('interest_bank', '10.0', 'Tasa de Interés - Bancario (%)'),
        ('interest_rapid', '20.0', 'Tasa de Interés - Rapidiario (%)'),
        ('company_initial_cash', '0.00', 'Dinero Inicial de la Empresa'),
        ('mod_clients_visible', '1', 'Visible Clientes'),
        ('mod_cash_visible', '1', 'Visible Caja'),
        ('mod_config_visible', '1', 'Visible Configuración'),
        ('mod_loan1_visible', '1', 'Visible Préstamo 1'),
        ('mod_loan2_visible', '1', 'Visible Préstamo 2'),
        ('mod_loan3_visible', '1', 'Visible Préstamo 3'),
        ('mod_loan4_visible', '0', 'Visible Préstamo 4'),
        ('mod_loan5_visible', '0', 'Visible Préstamo 5'),
        ('mod_calc_visible', '1', 'Visible Calculadora'),
        ('mod_analysis_visible', '1', 'Visible Análisis'),
        ('mod_docs_visible', '0', 'Visible Documentos'),
        ('mod_db_visible', '1', 'Visible Base de Datos'),
        ('mod_other1_visible', '0', 'Visible Otros 1'),
        ('mod_other2_visible', '0', 'Visible Otros 2'),
        ('label_clients', 'Clientes', 'Etiqueta Clientes'),
        ('label_cash', 'Caja', 'Etiqueta Caja'),
        ('label_config', 'Configuración', 'Etiqueta Configuración'),
        ('label_loan1', 'Casa de Empeño', 'Etiqueta Préstamo 1'),
        ('label_loan2', 'Préstamo Bancario', 'Etiqueta Préstamo 2'),
        ('label_loan3', 'Rapidiario', 'Etiqueta Préstamo 3'),
        ('label_loan4', 'Préstamo 4', 'Etiqueta Préstamo 4'),
        ('label_loan5', 'Préstamo 5', 'Etiqueta Préstamo 5'),
        ('label_calc', 'Calculadora', 'Etiqueta Calculadora'),
        ('label_analysis', 'Análisis', 'Etiqueta Análisis'),
        ('label_docs', 'Documentos', 'Etiqueta Documentos'),
        ('label_db', 'Base de Datos', 'Etiqueta Base de Datos'),
        ('label_other1', 'Otros 1', 'Etiqueta Otros 1'),
        ('label_other2', 'Otros 2', 'Etiqueta Otros 2'),
        ('app_theme', 'light', 'Tema de la Aplicación'),
    ]
    
    for key, val, desc in default_settings:
        cursor.execute('INSERT INTO settings (key, value, description) VALUES (%s, %s, %s) ON CONFLICT (key) DO NOTHING', (key, val, desc))

    # Default admin user
    cursor.execute("SELECT * FROM users WHERE username = 'admin'")
    if not cursor.fetchone():
        cursor.execute("INSERT INTO users (username, password, role, full_name, permissions) VALUES (%s, %s, %s, %s, %s)",
                       ('admin', 'admin123', 'admin', 'Administrador Principal', 'all'))

    conn.commit()
    conn.close()
    print("Base de datos PostgreSQL inicializada correctamente.")

if __name__ == '__main__':
    init_db()
